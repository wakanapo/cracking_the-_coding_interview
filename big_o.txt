VI.1 : O(b)
O(1)のループをb回回しているから。

VI.2 : O(b)
power()がb回呼ばれるから。

VI.3 : O(1)
割り算やかけ算の実行時間はa,bの大きさによらないから。

VI.4 : O(a/b)
a/b回O(1)のループを回すから。

VI.5 : O(log(n))
探索空間が半分になっていくから。

VI.6 : O(sqrt(n))
sqrt(n)回O(1)のループが回るから。

VI.7 : O(n)
最悪の場合は２分探索木のすべてのノードが一直線に連なっている場合である。その場合深さはnとなる。探す要素が木の末端にある場合が最悪のケースであり、n回探索することになる。

VI.8 : O(n)
すべての要素を探索することと変わらないから。

VI.9 : コピーしたい配列の長さをlとするとO(l^2)
appendToNew()の計算量はO(array.length)である。appendToNew()に渡すarrayの長さは0, 1, 2, ..., lというようにコピーしたい配列の長さまで１ずつ増えていく。従って計算量は
0 + 1 + 2 + ... + l = 1/2l(l+1) = O(l^2) となる。

VI.10 : O(log(n))
nの桁数分O(1)のループが回る。nの桁数はlog_10(n) + 1であらわすことができる。

VI.11 : O(k * 26^k)
printSortedStrings()は26^k回呼ばれる。printSortedStringsの計算量はkである。

VI.12 : O((a+b)log(b))
aの配列の長さをa、bの配列の長さをbとする。
margesort(b)の計算量はblog(b)。binarySearch(b, x)の計算量はlog(b)でそれがa回繰り返されるから全体の計算量はO((a+b)log(b))。
